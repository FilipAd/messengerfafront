{"ast":null,"code":"'use strict';\n\nconst {\n  signalsByName\n} = require('human-signals');\n\nconst getErrorPrefix = _ref => {\n  let {\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  } = _ref;\n\n  if (timedOut) {\n    return `timed out after ${timeout} milliseconds`;\n  }\n\n  if (isCanceled) {\n    return 'was canceled';\n  }\n\n  if (errorCode !== undefined) {\n    return `failed with ${errorCode}`;\n  }\n\n  if (signal !== undefined) {\n    return `was killed with ${signal} (${signalDescription})`;\n  }\n\n  if (exitCode !== undefined) {\n    return `failed with exit code ${exitCode}`;\n  }\n\n  return 'failed';\n};\n\nconst makeError = _ref2 => {\n  let {\n    stdout,\n    stderr,\n    all,\n    error,\n    signal,\n    exitCode,\n    command,\n    escapedCommand,\n    timedOut,\n    isCanceled,\n    killed,\n    parsed: {\n      options: {\n        timeout\n      }\n    }\n  } = _ref2;\n  // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n  // We normalize them to `undefined`\n  exitCode = exitCode === null ? undefined : exitCode;\n  signal = signal === null ? undefined : signal;\n  const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n  const errorCode = error && error.code;\n  const prefix = getErrorPrefix({\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  });\n  const execaMessage = `Command ${prefix}: ${command}`;\n  const isError = Object.prototype.toString.call(error) === '[object Error]';\n  const shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n  const message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n  if (isError) {\n    error.originalMessage = error.message;\n    error.message = message;\n  } else {\n    error = new Error(message);\n  }\n\n  error.shortMessage = shortMessage;\n  error.command = command;\n  error.escapedCommand = escapedCommand;\n  error.exitCode = exitCode;\n  error.signal = signal;\n  error.signalDescription = signalDescription;\n  error.stdout = stdout;\n  error.stderr = stderr;\n\n  if (all !== undefined) {\n    error.all = all;\n  }\n\n  if ('bufferedData' in error) {\n    delete error.bufferedData;\n  }\n\n  error.failed = true;\n  error.timedOut = Boolean(timedOut);\n  error.isCanceled = isCanceled;\n  error.killed = killed && !timedOut;\n  return error;\n};\n\nmodule.exports = makeError;","map":{"version":3,"sources":["/home/flic/test/node_modules/default-gateway/node_modules/execa/lib/error.js"],"names":["signalsByName","require","getErrorPrefix","timedOut","timeout","errorCode","signal","signalDescription","exitCode","isCanceled","undefined","makeError","stdout","stderr","all","error","command","escapedCommand","killed","parsed","options","description","code","prefix","execaMessage","isError","Object","prototype","toString","call","shortMessage","message","filter","Boolean","join","originalMessage","Error","bufferedData","failed","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst {signalsByName} = require('human-signals');\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nconst makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}}\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.escapedCommand = escapedCommand;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n\nmodule.exports = makeError;\n"]},"metadata":{},"sourceType":"script"}