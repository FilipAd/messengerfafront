{"ast":null,"code":"'use strict';\n\nconst os = require('os');\n\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5; // Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\n\nconst spawnedKill = function (kill) {\n  let signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const killResult = kill(signal);\n  setKillTimeout(kill, signal, options, killResult);\n  return killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n  if (!shouldForceKill(signal, options, killResult)) {\n    return;\n  }\n\n  const timeout = getForceKillAfterTimeout(options);\n  const t = setTimeout(() => {\n    kill('SIGKILL');\n  }, timeout); // Guarded because there's no `.unref()` when `execa` is used in the renderer\n  // process in Electron. This cannot be tested since we don't run tests in\n  // Electron.\n  // istanbul ignore else\n\n  if (t.unref) {\n    t.unref();\n  }\n};\n\nconst shouldForceKill = (signal, _ref, killResult) => {\n  let {\n    forceKillAfterTimeout\n  } = _ref;\n  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n  return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';\n};\n\nconst getForceKillAfterTimeout = _ref2 => {\n  let {\n    forceKillAfterTimeout = true\n  } = _ref2;\n\n  if (forceKillAfterTimeout === true) {\n    return DEFAULT_FORCE_KILL_TIMEOUT;\n  }\n\n  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n    throw new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n  }\n\n  return forceKillAfterTimeout;\n}; // `childProcess.cancel()`\n\n\nconst spawnedCancel = (spawned, context) => {\n  const killResult = spawned.kill();\n\n  if (killResult) {\n    context.isCanceled = true;\n  }\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n  spawned.kill(signal);\n  reject(Object.assign(new Error('Timed out'), {\n    timedOut: true,\n    signal\n  }));\n}; // `timeout` option handling\n\n\nconst setupTimeout = (spawned, _ref3, spawnedPromise) => {\n  let {\n    timeout,\n    killSignal = 'SIGTERM'\n  } = _ref3;\n\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise;\n  }\n\n  let timeoutId;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      timeoutKill(spawned, killSignal, reject);\n    }, timeout);\n  });\n  const safeSpawnedPromise = spawnedPromise.finally(() => {\n    clearTimeout(timeoutId);\n  });\n  return Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nconst validateTimeout = _ref4 => {\n  let {\n    timeout\n  } = _ref4;\n\n  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n    throw new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n  }\n}; // `cleanup` option handling\n\n\nconst setExitHandler = async (spawned, _ref5, timedPromise) => {\n  let {\n    cleanup,\n    detached\n  } = _ref5;\n\n  if (!cleanup || detached) {\n    return timedPromise;\n  }\n\n  const removeExitHandler = onExit(() => {\n    spawned.kill();\n  });\n  return timedPromise.finally(() => {\n    removeExitHandler();\n  });\n};\n\nmodule.exports = {\n  spawnedKill,\n  spawnedCancel,\n  setupTimeout,\n  validateTimeout,\n  setExitHandler\n};","map":{"version":3,"sources":["/home/flic/test/node_modules/default-gateway/node_modules/execa/lib/kill.js"],"names":["os","require","onExit","DEFAULT_FORCE_KILL_TIMEOUT","spawnedKill","kill","signal","options","killResult","setKillTimeout","shouldForceKill","timeout","getForceKillAfterTimeout","t","setTimeout","unref","forceKillAfterTimeout","isSigterm","constants","signals","SIGTERM","toUpperCase","Number","isFinite","TypeError","spawnedCancel","spawned","context","isCanceled","timeoutKill","reject","Object","assign","Error","timedOut","setupTimeout","spawnedPromise","killSignal","undefined","timeoutId","timeoutPromise","Promise","resolve","safeSpawnedPromise","finally","clearTimeout","race","validateTimeout","setExitHandler","timedPromise","cleanup","detached","removeExitHandler","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst os = require('os');\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nconst spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {\n\treturn isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n\treturn signal === os.constants.signals.SIGTERM ||\n\t\t(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n};\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nconst spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nconst setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nconst validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nconst setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n\nmodule.exports = {\n\tspawnedKill,\n\tspawnedCancel,\n\tsetupTimeout,\n\tvalidateTimeout,\n\tsetExitHandler\n};\n"]},"metadata":{},"sourceType":"script"}