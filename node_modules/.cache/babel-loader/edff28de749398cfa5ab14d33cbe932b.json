{"ast":null,"code":"\"use strict\";\n\nconst {\n  isIP\n} = require(\"net\");\n\nconst {\n  networkInterfaces\n} = require(\"os\");\n\nconst execa = require(\"execa\");\n\nconst gwArgs = \"path Win32_NetworkAdapterConfiguration where IPEnabled=true get DefaultIPGateway,GatewayCostMetric,IPConnectionMetric,Index /format:table\".split(\" \");\n\nconst ifArgs = index => `path Win32_NetworkAdapter where Index=${index} get NetConnectionID,MACAddress /format:table`.split(\" \");\n\nconst spawnOpts = {\n  windowsHide: true\n}; // Parsing tables like this. The final metric is GatewayCostMetric + IPConnectionMetric\n//\n// DefaultIPGateway             GatewayCostMetric  Index  IPConnectionMetric\n// {\"1.2.3.4\", \"2001:db8::1\"}   {0, 256}           12     25\n// {\"2.3.4.5\"}                  {25}               12     55\n\nfunction parseGwTable(gwTable, family) {\n  let [bestGw, bestMetric, bestId] = [null, null, null];\n\n  for (let line of (gwTable || \"\").trim().split(/\\r?\\n/).splice(1)) {\n    line = line.trim();\n    const [_, gwArr, gwCostsArr, id, ipMetric] = /({.+?}) +?({.+?}) +?([0-9]+) +?([0-9]+)/g.exec(line) || [];\n    if (!gwArr) continue;\n    const gateways = (gwArr.match(/\"(.+?)\"/g) || []).map(match => match.substring(1, match.length - 1));\n    const gatewayCosts = gwCostsArr.match(/[0-9]+/g) || [];\n\n    for (const [index, gateway] of Object.entries(gateways)) {\n      if (!gateway || `v${isIP(gateway)}` !== family) continue;\n      const metric = parseInt(gatewayCosts[index]) + parseInt(ipMetric);\n\n      if (!bestGw || metric < bestMetric) {\n        [bestGw, bestMetric, bestId] = [gateway, metric, id];\n      }\n    }\n  }\n\n  if (bestGw) return [bestGw, bestId];\n}\n\nfunction parseIfTable(ifTable) {\n  const line = (ifTable || \"\").trim().split(\"\\n\")[1];\n  let [mac, name] = line.trim().split(/\\s+/);\n  mac = mac.toLowerCase(); // try to get the interface name by matching the mac to os.networkInterfaces to avoid wmic's encoding issues\n  // https://github.com/silverwind/default-gateway/issues/14\n\n  for (const [osname, addrs] of Object.entries(networkInterfaces())) {\n    for (const addr of addrs) {\n      if (addr && addr.mac && addr.mac.toLowerCase() === mac) {\n        return osname;\n      }\n    }\n  }\n\n  return name;\n}\n\nconst promise = async family => {\n  const {\n    stdout\n  } = await execa(\"wmic\", gwArgs, spawnOpts);\n  const [gateway, id] = parseGwTable(stdout, family) || [];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  let name;\n\n  if (id) {\n    const {\n      stdout\n    } = await execa(\"wmic\", ifArgs(id), spawnOpts);\n    name = parseIfTable(stdout);\n  }\n\n  return {\n    gateway,\n    interface: name ? name : null\n  };\n};\n\nconst sync = family => {\n  const {\n    stdout\n  } = execa.sync(\"wmic\", gwArgs, spawnOpts);\n  const [gateway, id] = parseGwTable(stdout, family) || [];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  let name;\n\n  if (id) {\n    const {\n      stdout\n    } = execa.sync(\"wmic\", ifArgs(id), spawnOpts);\n    name = parseIfTable(stdout);\n  }\n\n  return {\n    gateway,\n    interface: name ? name : null\n  };\n};\n\nmodule.exports.v4 = () => promise(\"v4\");\n\nmodule.exports.v6 = () => promise(\"v6\");\n\nmodule.exports.v4.sync = () => sync(\"v4\");\n\nmodule.exports.v6.sync = () => sync(\"v6\");","map":{"version":3,"sources":["/home/flic/test/node_modules/default-gateway/win32.js"],"names":["isIP","require","networkInterfaces","execa","gwArgs","split","ifArgs","index","spawnOpts","windowsHide","parseGwTable","gwTable","family","bestGw","bestMetric","bestId","line","trim","splice","_","gwArr","gwCostsArr","id","ipMetric","exec","gateways","match","map","substring","length","gatewayCosts","gateway","Object","entries","metric","parseInt","parseIfTable","ifTable","mac","name","toLowerCase","osname","addrs","addr","promise","stdout","Error","interface","sync","module","exports","v4","v6"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst {isIP} = require(\"net\");\nconst {networkInterfaces} = require(\"os\");\nconst execa = require(\"execa\");\n\nconst gwArgs = \"path Win32_NetworkAdapterConfiguration where IPEnabled=true get DefaultIPGateway,GatewayCostMetric,IPConnectionMetric,Index /format:table\".split(\" \");\nconst ifArgs = index => `path Win32_NetworkAdapter where Index=${index} get NetConnectionID,MACAddress /format:table`.split(\" \");\n\nconst spawnOpts = {\n  windowsHide: true,\n};\n\n// Parsing tables like this. The final metric is GatewayCostMetric + IPConnectionMetric\n//\n// DefaultIPGateway             GatewayCostMetric  Index  IPConnectionMetric\n// {\"1.2.3.4\", \"2001:db8::1\"}   {0, 256}           12     25\n// {\"2.3.4.5\"}                  {25}               12     55\nfunction parseGwTable(gwTable, family) {\n  let [bestGw, bestMetric, bestId] = [null, null, null];\n\n  for (let line of (gwTable || \"\").trim().split(/\\r?\\n/).splice(1)) {\n    line = line.trim();\n    const [_, gwArr, gwCostsArr, id, ipMetric] = /({.+?}) +?({.+?}) +?([0-9]+) +?([0-9]+)/g.exec(line) || [];\n    if (!gwArr) continue;\n\n    const gateways = (gwArr.match(/\"(.+?)\"/g) || []).map(match => match.substring(1, match.length - 1));\n    const gatewayCosts = (gwCostsArr.match(/[0-9]+/g) || []);\n\n    for (const [index, gateway] of Object.entries(gateways)) {\n      if (!gateway || `v${isIP(gateway)}` !== family) continue;\n\n      const metric = parseInt(gatewayCosts[index]) + parseInt(ipMetric);\n      if (!bestGw || metric < bestMetric) {\n        [bestGw, bestMetric, bestId] = [gateway, metric, id];\n      }\n    }\n  }\n\n  if (bestGw) return [bestGw, bestId];\n}\n\nfunction parseIfTable(ifTable) {\n  const line = (ifTable || \"\").trim().split(\"\\n\")[1];\n\n  let [mac, name] = line.trim().split(/\\s+/);\n  mac = mac.toLowerCase();\n\n  // try to get the interface name by matching the mac to os.networkInterfaces to avoid wmic's encoding issues\n  // https://github.com/silverwind/default-gateway/issues/14\n  for (const [osname, addrs] of Object.entries(networkInterfaces())) {\n    for (const addr of addrs) {\n      if (addr && addr.mac && addr.mac.toLowerCase() === mac) {\n        return osname;\n      }\n    }\n  }\n  return name;\n}\n\nconst promise = async family => {\n  const {stdout} = await execa(\"wmic\", gwArgs, spawnOpts);\n  const [gateway, id] = parseGwTable(stdout, family) || [];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  let name;\n  if (id) {\n    const {stdout} = await execa(\"wmic\", ifArgs(id), spawnOpts);\n    name = parseIfTable(stdout);\n  }\n\n  return {gateway, interface: name ? name : null};\n};\n\nconst sync = family => {\n  const {stdout} = execa.sync(\"wmic\", gwArgs, spawnOpts);\n  const [gateway, id] = parseGwTable(stdout, family) || [];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  let name;\n  if (id) {\n    const {stdout} = execa.sync(\"wmic\", ifArgs(id), spawnOpts);\n    name = parseIfTable(stdout);\n  }\n\n  return {gateway, interface: name ? name : null};\n};\n\nmodule.exports.v4 = () => promise(\"v4\");\nmodule.exports.v6 = () => promise(\"v6\");\n\nmodule.exports.v4.sync = () => sync(\"v4\");\nmodule.exports.v6.sync = () => sync(\"v6\");\n"]},"metadata":{},"sourceType":"script"}