{"ast":null,"code":"'use strict';\n\nconst isStream = require('is-stream');\n\nconst getStream = require('get-stream');\n\nconst mergeStream = require('merge-stream'); // `input` option\n\n\nconst handleInput = (spawned, input) => {\n  // Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n  // @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n  if (input === undefined || spawned.stdin === undefined) {\n    return;\n  }\n\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n}; // `all` interleaves `stdout` and `stderr`\n\n\nconst makeAllStream = (spawned, _ref) => {\n  let {\n    all\n  } = _ref;\n\n  if (!all || !spawned.stdout && !spawned.stderr) {\n    return;\n  }\n\n  const mixed = mergeStream();\n\n  if (spawned.stdout) {\n    mixed.add(spawned.stdout);\n  }\n\n  if (spawned.stderr) {\n    mixed.add(spawned.stderr);\n  }\n\n  return mixed;\n}; // On failure, `result.stdout|stderr|all` should contain the currently buffered stream\n\n\nconst getBufferedData = async (stream, streamPromise) => {\n  if (!stream) {\n    return;\n  }\n\n  stream.destroy();\n\n  try {\n    return await streamPromise;\n  } catch (error) {\n    return error.bufferedData;\n  }\n};\n\nconst getStreamPromise = (stream, _ref2) => {\n  let {\n    encoding,\n    buffer,\n    maxBuffer\n  } = _ref2;\n\n  if (!stream || !buffer) {\n    return;\n  }\n\n  if (encoding) {\n    return getStream(stream, {\n      encoding,\n      maxBuffer\n    });\n  }\n\n  return getStream.buffer(stream, {\n    maxBuffer\n  });\n}; // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\n\n\nconst getSpawnedResult = async (_ref3, _ref4, processDone) => {\n  let {\n    stdout,\n    stderr,\n    all\n  } = _ref3;\n  let {\n    encoding,\n    buffer,\n    maxBuffer\n  } = _ref4;\n  const stdoutPromise = getStreamPromise(stdout, {\n    encoding,\n    buffer,\n    maxBuffer\n  });\n  const stderrPromise = getStreamPromise(stderr, {\n    encoding,\n    buffer,\n    maxBuffer\n  });\n  const allPromise = getStreamPromise(all, {\n    encoding,\n    buffer,\n    maxBuffer: maxBuffer * 2\n  });\n\n  try {\n    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n  } catch (error) {\n    return Promise.all([{\n      error,\n      signal: error.signal,\n      timedOut: error.timedOut\n    }, getBufferedData(stdout, stdoutPromise), getBufferedData(stderr, stderrPromise), getBufferedData(all, allPromise)]);\n  }\n};\n\nconst validateInputSync = _ref5 => {\n  let {\n    input\n  } = _ref5;\n\n  if (isStream(input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n};\n\nmodule.exports = {\n  handleInput,\n  makeAllStream,\n  getSpawnedResult,\n  validateInputSync\n};","map":{"version":3,"sources":["/home/flic/test/node_modules/default-gateway/node_modules/execa/lib/stream.js"],"names":["isStream","require","getStream","mergeStream","handleInput","spawned","input","undefined","stdin","pipe","end","makeAllStream","all","stdout","stderr","mixed","add","getBufferedData","stream","streamPromise","destroy","error","bufferedData","getStreamPromise","encoding","buffer","maxBuffer","getSpawnedResult","processDone","stdoutPromise","stderrPromise","allPromise","Promise","signal","timedOut","validateInputSync","TypeError","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst isStream = require('is-stream');\nconst getStream = require('get-stream');\nconst mergeStream = require('merge-stream');\n\n// `input` option\nconst handleInput = (spawned, input) => {\n\t// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n\t// @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n\tif (input === undefined || spawned.stdin === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nconst makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nconst getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise)\n\t\t]);\n\t}\n};\n\nconst validateInputSync = ({input}) => {\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n};\n\nmodule.exports = {\n\thandleInput,\n\tmakeAllStream,\n\tgetSpawnedResult,\n\tvalidateInputSync\n};\n\n"]},"metadata":{},"sourceType":"script"}